---
title: I/O复用与多线程、多进程区别
date: 2016-05-14
tags: [php]
category: [php]
---
相比与单线程单进程，以上三种都特别快,但是他们之间有什么区别呢？
首先声明一点，这三者并不冲突，多线程中能够使用I/O复用，多进程中又能够使用多线程，工作中可以将三者结合起来一起使用。
<!--more-->
## I/O复用
#### 1、什么是I/O复用
让应用程序可以同时对多个I/O端口进行监控以判断其上的操作是否可以进行，达到时间复用的目的。在书上看到一个例子来解释I/O的原理，我觉得很形象，如果用监控来自10根不同地方的水管（I/O端口）是否有水流到达（即是否可读），那么需要10个人（即10个线程或10处代码）来做这件事。如果利用某种技术（比如摄像头）把这10根水管的状态情况统一传达到某一点，那么就只需要1个人在那个点进行监控就行了，而类似与select或epoll这样的多路I/O复用机制就好比是摄像头的功能，它们能够把多个I/O端口的状况反馈到同一处，比如某个特定的文件描述符上，这样应用程序只需利用对应的select()或epoll_wait()系统调用阻塞关注这一处即可。
#### 2、I/O模型优点
可以同时监视这么多的房间，但是仅仅用了单线程单进程，可见使用的效率之高，所占资源之少，而且避免了多线程的死锁的问题，避免了多进程的资源不能共享的问题。
#### 3、I/O模型例子
C 中有select、poll、epoll
php 中有`curl_multi_*()`函数簇

## 多进程模式
#### 1、多进程简介
c中的fork函数，php中的pcntl_fork函数，都是用来创建多进程，比较简单
eg:
```
for($i = 0 ; $i < 5;$i++){
    $pid = pcntl_fork();
    if($pid == -1){
        echo "fork child process   failed\n";
    exit(0);
    }
    if($pid == 0){
    //子进程返回值为0；接下来执行子进程代码
    sleep(1);
    self::callback_function();
    }
    else{
    //父进程返回值为子进程的pid
    echo "create process $pid success!\n";
    $this->process_arr[] = $pid;
    }
}
```
#### 2、多进程优点
- 每个进程相互独立，不会影响程序的稳定性，就算一个进程崩了，别的进程也能继续执行。
- 通过增加CPU就可以扩充性能，因为一般进程开启数量为cpu的1到2倍的效率最高的时候。
- 可以尽量减少线程加锁/解锁的影响，减少死锁发生的概率。也提升了效率。
- 每个子进程有2G地址空间和相关资源，性能特别强大
#### 3、多进程缺点
- 逻辑困难，需要与主进程交互
- 资源不能共享，需要通过进程通信来实现资源共享，比如管道通信、socket、内存数据库等。所以不太适合大量数据的传输。
- 多进程调度开销大，每个切换需要先保存上下文，切回的时候又要把上下文弄回来。
## 多线程模型
#### 1、多线程简介
每个线程都有自己的线程上下文，包括一个线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。由于线程运行在单一进程中，因此共享这个进程虚拟地址空间的整个内容，包括它的代码、数据、堆、共享库和打开的文件。

线程执行的模型：线程和进程的执行模型有些相似，每个进程的声明周期都是一个线程，我们称之为主线程。线程是对等的，主线程跟其他线程的区别就是它先执行。
#### 2、多线程优点
- 一个进程中的线程资源共享
- 程序逻辑和控制方式比较简单
- 线程创建和切换所消耗的资源与时间都比较少
#### 3、多线程缺点
- 每个线程与主程序共用地址空间，受限于2GB地址空间；
- 线程之间的同步和加锁控制比较麻烦；
- 一个线程的崩溃可能影响到整个程序的稳定性；